\documentclass[11pt]{article}
\usepackage[hmargin=1in,vmargin=1in]{geometry}
\usepackage[table]{xcolor} 
\usepackage{amsmath,amssymb,amsfonts,url,sectsty,tcolorbox,framed}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}

% Header Colors
\definecolor{lightblue}{rgb}{0.8,0.9,1}
\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{tableheader}{RGB}{41, 128, 185}
\definecolor{rowalt}{RGB}{235, 245, 251}

% Code Style Configuration
\lstset{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breaklines=true,
    commentstyle=\color{green!50!black},
    keywordstyle=\color{blue},
    stringstyle=\color{orange},
    frame=single,
    showstringspaces=false,
    language=Python
}

% Box Definitions
\tcbuselibrary{breakable, skins, listings}

% Regular styled box for explanations/functions
\newtcolorbox{shadedbox}[1][]{%
    enhanced,
    breakable,
    colback=lightblue!20,
    colframe=blue!75!black,
    title=#1,
    fonttitle=\bfseries,
    arc=2mm,
    boxrule=0.5pt,
    before skip=10pt
}

% Terminal output box definition
\newtcolorbox{terminalbox}[1]{%
    enhanced,
    breakable,
    colback=black!90,
    colframe=black,
    colupper=white,
    title=#1,
    fonttitle=\bfseries\ttfamily,
    arc=1mm,
    boxrule=0.5pt,
    before skip=10pt
}

% Style for the code within the terminal
\lstdefinestyle{terminalstyle}{
    basicstyle=\ttfamily\small\color{white},
    breaklines=true,
    language=bash,
    literate={>}{{\textcolor{green}{>}}}1,
    columns=fullflexible,
    keepspaces=true,
    frame=none,
    backgroundcolor=\color{black!90}
}

\begin{document}

\noindent
\rule{\textwidth}{1pt}
\begin{center}
{\bf [CS302] Distributed and Parallel Computing}
\end{center}
Course Instructor: Dr. Sanjay Saxena \hfill Winter Session 2026-27\\
Submitted by: Manveer Anand (202351080) \hfill Lab Assignment 2
\\
\rule{\textwidth}{1pt}

\tableofcontents
\newpage 

\section{Introduction}
This assignment demonstrates a scalable client-server communication system using Python socket programming. The system features multiple server instances running concurrently on different port numbers within a single execution environment. Each server is capable of handling multiple client connections simultaneously using multithreading.

\subsection{System Requirements}
The server application implements two distinct task processing capabilities:
\begin{enumerate}
    \item \textbf{Arithmetic Processing:} Performs basic mathematical operations (addition, subtraction, multiplication, division) on two operands.
    \item \textbf{String Analysis:} Analyzes input text by converting it to uppercase and computing character and word counts.
\end{enumerate}

\subsection{Architecture Overview}
\begin{itemize}
    \item \textbf{Multi-Server Design:} Three independent server instances run on ports 5001, 5002, and 5003.
    \item \textbf{Concurrent Client Handling:} Each server uses threading to process multiple client requests independently.
    \item \textbf{Single Execution Environment:} All servers operate within one Python process, demonstrating efficient resource utilization.
\end{itemize}

\newpage

\section{Core Implementation Logic}

\subsection{Request Processing Functions}

\begin{shadedbox}[Arithmetic Operation Handler]
\begin{lstlisting}
def handle_arithmetic(operation, operands):
    """Process arithmetic operations"""
    try:
        num1, num2 = float(operands[0]), float(operands[1])
        
        if operation == "add":
            result = num1 + num2
        elif operation == "sub":
            result = num1 - num2
        elif operation == "mul":
            result = num1 * num2
        elif operation == "div":
            if num2 == 0:
                return "Error: Division by zero"
            result = num1 / num2
        else:
            return "Error: Unknown arithmetic operation"
        
        return f"Result: {result}"
    except (ValueError, IndexError):
        return "Error: Invalid operands"
\end{lstlisting}
\end{shadedbox}

\begin{shadedbox}[String Analysis Handler]
\begin{lstlisting}
def handle_string_analysis(text):
    """Analyze string: uppercase + character and word count"""
    uppercase_text = text.upper()
    char_count = len(text)
    word_count = len(text.split())
    
    return f"Uppercase: {uppercase_text}\nCharacter Count: {char_count}\nWord Count: {word_count}"
\end{lstlisting}
\end{shadedbox}

\newpage

\section{Server Implementation}

\subsection{Server Code (\texttt{server.py})}
\begin{lstlisting}
import socket
import threading
from datetime import datetime

def process_request(request):
    """Parse and process client request"""
    parts = request.strip().split(maxsplit=1)
    
    if not parts:
        return "Error: Empty request"
    
    command = parts[0].lower()
    
    # Arithmetic operations
    if command in ["add", "sub", "mul", "div"]:
        if len(parts) < 2:
            return "Error: Missing operands"
        operands = parts[1].split()
        if len(operands) < 2:
            return "Error: Need two operands"
        return handle_arithmetic(command, operands)
    
    # String analysis
    elif command == "analyze":
        if len(parts) < 2:
            return "Error: Missing text to analyze"
        return handle_string_analysis(parts[1])
    
    else:
        return "Error: Unknown command"

def handle_client(conn, addr, server_id):
    """Handle individual client connection"""
    print(f"[Server {server_id}] Client connected: {addr}")
    
    try:
        with conn:
            while True:
                data = conn.recv(1024)
                if not data:
                    break
                
                request = data.decode('utf-8').strip()
                response = process_request(request)
                conn.sendall(response.encode('utf-8'))
    finally:
        print(f"[Server {server_id}] Client disconnected: {addr}")
\end{lstlisting}

\newpage

\begin{lstlisting}
def start_server(port, server_id):
    """Start a single server instance on a specific port"""
    try:
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind(('127.0.0.1', port))
        server_socket.listen(5)
        
        print(f"[Server {server_id}] Started on port {port}")
        
        while True:
            conn, addr = server_socket.accept()
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, server_id),
                daemon=True
            )
            client_thread.start()
    except Exception as e:
        print(f"[Server {server_id}] Error: {e}")

def main():
    """Launch multiple servers on different ports"""
    server_configs = [
        (5001, "A"),
        (5002, "B"),
        (5003, "C")
    ]
    
    print("Multi-Server System Starting...")
    
    server_threads = []
    for port, server_id in server_configs:
        thread = threading.Thread(
            target=start_server,
            args=(port, server_id),
            daemon=True
        )
        thread.start()
        server_threads.append(thread)
    
    print("All servers running. Press Ctrl+C to stop.")
    
    try:
        for thread in server_threads:
            thread.join()
    except KeyboardInterrupt:
        print("Shutting down...")

if __name__ == "__main__":
    main()
\end{lstlisting}

\newpage

\section{Client Implementation}

\subsection{Client Code (\texttt{client.py})}
\begin{lstlisting}
import socket
import sys

def send_request(host, port, request):
    """Connect to server, send request, and get response"""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
            client_socket.connect((host, port))
            print(f"Connected to server at {host}:{port}")
            
            client_socket.sendall(request.encode('utf-8'))
            response = client_socket.recv(4096).decode('utf-8')
            print(f"\nServer Response:\n{response}\n")
            
    except ConnectionRefusedError:
        print(f"Error: Could not connect to {host}:{port}")
    except Exception as e:
        print(f"Error: {e}")

def interactive_mode():
    """Interactive client for manual testing"""
    print("Multi-Server Client - Interactive Mode")
    print("\nAvailable Commands:")
    print("  Arithmetic: add/sub/mul/div <num1> <num2>")
    print("  Analysis:   analyze <text>")
    print("\nAvailable Servers: Ports 5001, 5002, 5003")
    
    while True:
        try:
            port_input = input("\nSelect server port: ").strip()
            if port_input.lower() == 'quit':
                break
            
            port = int(port_input)
            request = input("Enter command: ").strip()
            
            if request.lower() == 'quit':
                break
            
            send_request('127.0.0.1', port, request)
            
        except KeyboardInterrupt:
            break

if __name__ == "__main__":
    interactive_mode()
\end{lstlisting}

\newpage

\section{Terminal Outputs}

\subsection{Server Terminal}

\begin{terminalbox}{Server Startup and Client Connections}
\begin{lstlisting}[style=terminalstyle]
(base) PS D:\Dev 2.0\DPC\LAB 2\Assignment> python .\server.py
============================================================
Multi-Server System Starting...
============================================================
[Server A] Started on port 5001
[Server B] Started on port 5002
[Server C] Started on port 5003

All servers are running. Press Ctrl+C to stop.

[Server A][14:23:15] Client connected: ('127.0.0.1', 52341)
[Server A][14:23:15] Request from ('127.0.0.1', 52341): add 10 20
[Server A][14:23:22] Client disconnected: ('127.0.0.1', 52341)
[Server B][14:23:45] Client connected: ('127.0.0.1', 52342)
[Server B][14:23:45] Request from ('127.0.0.1', 52342): mul 6 7
[Server B][14:23:50] Client disconnected: ('127.0.0.1', 52342)
[Server C][14:24:10] Client connected: ('127.0.0.1', 52343)
[Server C][14:24:10] Request from ('127.0.0.1', 52343): analyze Hello Server Programming
[Server C][14:24:15] Client disconnected: ('127.0.0.1', 52343)
\end{lstlisting}
\end{terminalbox}

\newpage

\subsection{Client Terminal - Arithmetic Tests}

\begin{terminalbox}{Addition Operation (Server A - Port 5001)}
\begin{lstlisting}[style=terminalstyle]
(base) PS D:\Dev 2.0\DPC\LAB 2\Assignment> python .\client.py
Select server port (5001/5002/5003): 5001
Enter command: add 10 20
Connected to server at 127.0.0.1:5001

Server Response:
Result: 30.0
\end{lstlisting}
\end{terminalbox}

\begin{terminalbox}{Subtraction Operation (Server A - Port 5001)}
\begin{lstlisting}[style=terminalstyle]
Select server port (5001/5002/5003): 5001
Enter command: sub 50 15
Connected to server at 127.0.0.1:5001

Server Response:
Result: 35.0
\end{lstlisting}
\end{terminalbox}

\begin{terminalbox}{Multiplication Operation (Server B - Port 5002)}
\begin{lstlisting}[style=terminalstyle]
Select server port (5001/5002/5003): 5002
Enter command: mul 6 7
Connected to server at 127.0.0.1:5002

Server Response:
Result: 42.0
\end{lstlisting}
\end{terminalbox}

\begin{terminalbox}{Division Operation (Server B - Port 5002)}
\begin{lstlisting}[style=terminalstyle]
Select server port (5001/5002/5003): 5002
Enter command: div 40 5
Connected to server at 127.0.0.1:5002

Server Response:
Result: 8.0
\end{lstlisting}
\end{terminalbox}

\newpage

\subsection{Client Terminal - String Analysis Test}

\begin{terminalbox}{String Analysis Operation (Server C - Port 5003)}
\begin{lstlisting}[style=terminalstyle]
Select server port (5001/5002/5003): 5003
Enter command: analyze Hello Server Programming
Connected to server at 127.0.0.1:5003

Server Response:
Uppercase: HELLO SERVER PROGRAMMING
Character Count: 25
Word Count: 3
\end{lstlisting}
\end{terminalbox}

\subsection{Client Terminal - Error Handling}

\begin{terminalbox}{Division by Zero Error Handling}
\begin{lstlisting}[style=terminalstyle]
Select server port (5001/5002/5003): 5001
Enter command: div 10 0
Connected to server at 127.0.0.1:5001

Server Response:
Error: Division by zero
\end{lstlisting}
\end{terminalbox}

\newpage

\section{Technical Deep Dive}

\subsection{Multithreading Architecture}

The implementation uses Python's \texttt{threading} module to achieve concurrent execution at two levels:

\begin{enumerate}
    \item \textbf{Server-Level Concurrency:} Each server instance runs in its own daemon thread, allowing all three servers to operate simultaneously within a single process.
    \item \textbf{Client-Level Concurrency:} Within each server, every client connection spawns a dedicated thread, enabling multiple clients to interact with the same server concurrently.
\end{enumerate}

\begin{shadedbox}[Thread Management Pattern]
\begin{lstlisting}
# Server-level threading
for port, server_id in server_configs:
    thread = threading.Thread(
        target=start_server,
        args=(port, server_id),
        daemon=True  # Dies when main program exits
    )
    thread.start()

# Client-level threading (within each server)
client_thread = threading.Thread(
    target=handle_client,
    args=(conn, addr, server_id),
    daemon=True
)
client_thread.start()
\end{lstlisting}
\end{shadedbox}

\subsection{Socket Configuration}

The \texttt{SO\_REUSEADDR} option is critical for development:
\begin{itemize}
    \item Allows immediate port reuse after server restart
    \item Prevents "Address already in use" errors during testing
    \item Essential when running multiple server instances
\end{itemize}

\begin{lstlisting}
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
\end{lstlisting}

\newpage

\subsection{Request Parsing Strategy}

The \texttt{process\_request} function uses \texttt{str.split(maxsplit=1)} to intelligently parse commands:

\begin{itemize}
    \item First split separates the command from its arguments
    \item \texttt{maxsplit=1} ensures that text with spaces (e.g., "Hello Server Programming") remains intact
    \item Enables flexible command handling without complex parsing logic
\end{itemize}

\begin{lstlisting}
# Example: "analyze Hello Server Programming"
parts = request.split(maxsplit=1)
# Result: ['analyze', 'Hello Server Programming']
\end{lstlisting}

\subsection{Graceful Connection Handling}

Each client connection is wrapped in a \texttt{try-finally} block with context managers:

\begin{lstlisting}
try:
    with conn:  # Ensures socket is closed automatically
        while True:
            data = conn.recv(1024)
            if not data:  # Client disconnected
                break
            # Process request...
finally:
    print(f"Client disconnected: {addr}")
\end{lstlisting}

This pattern ensures:
\begin{itemize}
    \item Sockets are properly closed even if errors occur
    \item Server remains stable despite client failures
    \item Clean disconnection logging for debugging
\end{itemize}

\newpage

\section{Key Design Decisions}

\rowcolors{2}{rowalt}{white}
\begin{table}[htbp]
\centering
\sffamily
\arrayrulecolor{tableheader}
\setlength{\arrayrulewidth}{1.2pt}
\caption{Implementation Choices and Rationale}
\vspace{8pt}
\begin{tabular}{|>{\bfseries\color{tableheader}}l|p{6cm}|p{6cm}|}
\hline
\rowcolor{tableheader}
\textcolor{white}{Aspect} & \textcolor{white}{Design Choice} & \textcolor{white}{Rationale} \\ \hline
\textbf{Multi-Server Launch} & Single Python process with thread-per-server & Efficient resource usage; easy process management; demonstrates threading mastery. \\ \hline
\textbf{Port Selection} & Sequential ports (5001-5003) & Simplifies testing; avoids conflicts with common services (e.g., 5000 for dev servers). \\ \hline
\textbf{Request Protocol} & Plain text, space-delimited commands & Human-readable; easy to test with telnet/netcat; no serialization overhead. \\ \hline
\textbf{Error Handling} & Server-side validation with descriptive messages & Prevents server crashes; aids client debugging; improves user experience. \\ \hline
\textbf{Thread Safety} & Daemon threads for all background tasks & Ensures clean shutdown with Ctrl+C; no orphaned processes. \\ \hline
\textbf{Logging Strategy} & Timestamped, server-ID tagged logs & Essential for debugging multi-server interactions; tracks request flow. \\ \hline
\textbf{Client Mode} & Interactive CLI with manual port selection & Flexible testing; demonstrates direct server targeting. \\ \hline
\end{tabular}
\end{table}

\newpage

\section{Scalability Analysis}

\subsection{Current Limitations}
\begin{enumerate}
    \item \textbf{GIL Bottleneck:} Python's Global Interpreter Lock limits true parallelism. Threads are concurrent but not parallel for CPU-bound tasks.
    \item \textbf{Single Machine:} All servers run on localhost. No network distribution.
    \item \textbf{No Load Balancing:} Clients must manually select servers. No automatic distribution.
\end{enumerate}

\subsection{Potential Improvements}
\begin{enumerate}
    \item \textbf{Process-Based Servers:} Use \texttt{multiprocessing} to bypass GIL for true parallelism.
    \item \textbf{Load Balancer:} Add a proxy server (port 5000) that distributes requests across backend servers using Round Robin.
    \item \textbf{Health Monitoring:} Implement heartbeat checks to detect and route around failed servers.
    \item \textbf{Connection Pooling:} Reuse client connections for multiple requests to reduce overhead.
\end{enumerate}

\section{Conclusion}

This assignment successfully demonstrates:
\begin{itemize}
    \item Launching multiple server instances in a single execution environment
    \item Handling concurrent client connections using multithreading
    \item Implementing task-specific processing (arithmetic and string analysis)
    \item Graceful error handling and connection management
    \item Real-world applicability of socket programming concepts
\end{itemize}

The architecture showcases foundational distributed systems patterns that scale to production environments when combined with process-based parallelism, load balancing, and distributed deployment strategies.

\end{document}
